---
title: "How to create plot from Likert-scale data"
---

The answers in the example above are arranged on a 5-point Likert scale. This means that respondents indicate a degree to which they agree with a particular statement from 1 - "strongly disagree" to 5 - "strongly agree". However, a Likert scale could contain from 3 to 7 points of reference.

A nice visualization of Likert-scale answers is a stacked bar chart anchored in the middle of most "indifferent" part of survey sample. The position of each bar represents the balance of opinion. The more the bar is shifted to a particular direction, the more agreeable or disagreeable the population is. Thus multiple bars can be easily compared to each other. Obtaining such plot requires, however, some effort. I have tried two ways of doing it: 

1. The first one is more tedious, but allows for more flexibility. It uses *ggplot2* package and "geom_bar" aestethics. You can find it's description here: http://rnotr.com/likert/ggplot/barometer/likert-plots/

2. The second one comes from the same author (http://rnotr.com/likert/ggplot/barometer/likert-plotly/) and also uses *ggplot2* but with "geom_segment" aestethics. It is simpler and more concise, but also blocks "color" argument for other use on the chart. This might be a problem if you want to have data-labels on the chart and color them black on light background and white on dark background. 

## 1. Preparing data for a very basic Likert-scale plot.

Let's start with preparing some survey data, accoring to a recipe described in "Home" tab.
```{r eval = TRUE, include = TRUE, echo = TRUE}
data_2 <- read.csv("survey_data.csv")
answers <- names(wpct(data_2$Question, weight = data_2$WeightPerCountry))
freq_table_2 <- data_2 %>% 
  group_by(Country) %>%
  do(as.data.frame(wpct(.$Question, .$WeightPerCountry, na.rm = TRUE))) %>%
  mutate(answers = answers) %>% 
  spread(key = answers, `wpct(.$Question, .$WeightPerCountry, na.rm = TRUE)`)
```
We've got a dataframe where each row denotes a country (15 totaland each collumn a percentages of people sharing a Likert-scale opinion to "Statement" 
```{r message = FALSE, echo = FALSE, eval = TRUE}
kable(freq_table_2, "html") %>% 
  kable_styling(bootstrap_options = "striped", 
                full_width = FALSE, 
                position = "left")
```


Our first step in obtaining Likert-style plot is to divide the middle group (in our case: "Neither agree nor disagree" group) into two equal subgroups. To do that mutate freq_table in the following way and then order the columns from least agreeable to most agreeable (getting rid of now obsolete `Neither agree nor disagree` column in the process).

```{r eval = TRUE, include = TRUE, echo = TRUE}
freq_table_2 <- freq_table_2 %>% 
  mutate(Midlow = `Neither agree nor disagree`/2,
         Midhigh = `Neither agree nor disagree`/2)

freq_table_2 <- freq_table_2[c(1, 6, 3, 7, 8, 2, 5)]
```
Third step is to transform your data into a long format. One popular way of doing it is to use *melt* function from *reshape2* package. However, if you like to stay within *tidyverse* framework you may use a *gather* function from *dplyr* package. Let's use it then...

```{r eval = TRUE, include = TRUE, echo = TRUE}
freq_table_long_2 <- freq_table_2 %>% 
  gather(key = "key", value = "value", 2:7, - Country) %>% 
  mutate(color = palette)

freq_table_long_2$key <- factor(freq_table_long_2$key, 
                                levels = c("Strongly disagree",
                                           "Disagree",
                                           "Midlow", 
                                           "Midhigh",
                                           "Agree", 
                                           "Strongly agree")) 
freq_table_long_2$Country <- factor(freq_table_long_2$Country,
                                    levels = freq_table_2$Country[order(-(freq_table_2[, 5] + freq_table_2[, 6] + freq_table_2[, 7]))])
```
to obtain:
```{r message = FALSE, echo = FALSE, eval = TRUE}
kable(head(freq_table_long_2), "html") %>% 
  kable_styling(bootstrap_options = "striped", 
                full_width = FALSE, 
                position = "left")
```

Next step is to split the freq_table_long into two separate datasets, one for positive bars ("highs") and the other for negative bars ("lows"). Those datasets should be ordered separately in this specific way. Otherwise the bars on the chart will be stacked in the wrong order. 

```{r message = FALSE, echo = TRUE, eval = TRUE, include = TRUE}
lows <- freq_table_long_2[1:(nrow(freq_table_long_2)/2),]
lows$key <- factor(lows$key, levels = c("Strongly disagree", "Disagree", "Midlow"))

highs <- freq_table_long_2[(nrow(freq_table_long_2)/2+1):nrow(freq_table_long_2),]
highs$key <- factor(highs$key, levels = c("Strongly agree","Agree", "Midhigh"))
```

This is enough to create a very basic Likert-scale plot. It shows quite well, which country is most leaning to agree with the statment that "Statement" and which tends to disagree most often. However, the colors on the chart and the legend are very confusing and need to be improved. 

```{r message = FALSE, echo = FALSE, eval = TRUE}
ggplot() +
  geom_bar(data = highs, 
           aes(x = Country, 
               y = value, 
               fill = key),
           stat = "identity") +
  geom_bar(data = lows, 
           aes(x = Country, 
               y = - value, 
               fill = key),
           stat = "identity") +
  theme(legend.position = "right") +
  coord_flip()
```

## 2. Adding colors to the Likert-style plot.

In order to align colors on the chart and on the legend you need to specify two palettes. One for legend - with separate color for each Likert-scale answer. And the other one with doubled color for the middle answer on the Likert scale (for "Midlow" and "Midhigh" separately). Moreover, we need to specify what will appear on the legend. I usually work with palette with violets for negative answers and oranges for positive ones with grey reserved for ambiguity:

```{r message = FALSE, echo = TRUE, eval = TRUE, include = TRUE}
palette_legend <- c("#525199", "#9393C6", "#A8A8A8", "#FFA166", "#FF6200")
palette_plot <- c("#525199", "#9393C6", "#A8A8A8", "#A8A8A8", "#FFA166", "#FF6200")

legend <- c("Strongly disagree", "Disagree", "Neither disagree,\nnor agree", "Agree", "Strongly agree")
```

In order to include these colors in the plot we need to go back to the freq_table_long_2 and assign an appropriate color to each key by adding a new column. Next you need to split the table into highs and lows again and arrange them as factors in correct order. 

```{r eval = TRUE, include = TRUE, echo = TRUE}
freq_table_long_2$color <- rep(palette_plot, each = length(unique(freq_table_long_2$Country)))

lows <- freq_table_long_2[1:(nrow(freq_table_long_2)/2),]
lows$key <- factor(lows$key, levels = c("Strongly disagree", "Disagree", "Midlow"))

highs <- freq_table_long_2[(nrow(freq_table_long_2)/2+1):nrow(freq_table_long_2),]
highs$key <- factor(highs$key, levels = c("Strongly agree","Agree", "Midhigh"))
highs$color <- factor(highs$color, levels = c("#FF6200","#FFA166","#A8A8A8"))

```
Now we can draw the plot again, but this time the fill parameter in the geom_bar will be assigned the color variable instead of key variable. 
```{r message = FALSE, echo = FALSE, eval = TRUE}
ggplot() +
  geom_bar(data = highs, 
           aes(x = Country, 
               y = value, 
               fill = color),
           stat = "identity") +
  geom_bar(data = lows, 
           aes(x = Country, 
               y = - value, 
               fill = color),
           stat = "identity") +
  theme(legend.position = "right") +
  scale_fill_identity("", labels = legend, breaks = palette_legend, guide = "legend") + 
  scale_color_manual(values = palette_plot, guide = FALSE) +
  coord_flip()
```
It looks much better.